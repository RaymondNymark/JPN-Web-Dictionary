@page "/"
@page "/Search"
@page "/Search/{SearchTerm}" 

@using Dictionary.Core.Services
@using Dictionary.Core.Models

@inject IJSRuntime _jsRunTime
@inject IDictionarySearchService _dictionarySearchService

<h3 id="main_header">Japanese Search!</h3><br />
<div id="main_search" class="main">
    <input type="text" id="txt_input" placeholder="Love, happiness.." @bind-value="@_searchTerm" />
    <input type="button" id="txt_button" value="Search" @onclick="@SearchDictionaryManuallyAsync"/>
</div>
<br />
@if (dictionaryEntries == null)
{
    <div class="skinny_information_text">
        <br />
        <p>A simple Japanese-English dictionary using the Jisho.api to find Japanese words, readings, kanji, and so on. </p>
        <p>Enter any Japanese or English words or text in the search box, like 'love' or 'summer' and the results will be presented.</p>
        <p>This blazor.application is created by me, <a id="themedurl" href="https://github.com/RaymondNymark"><u>Raymond Nymark</u></a> 😊</p>
    </div>
}
else
{
    <div id="result_count">
        <h5>
            Results
            <span class="result_count"> ー @_entryCount found</span>
        </h5>
    </div>
    <br />
    @foreach (var entry in dictionaryEntries)
    {
        <div class="single_dictionary_entry">
            <div class="japanese_info">
                <div class="japanese_word_entry">
                    @if (string.IsNullOrEmpty(entry.JapaneseData.First().Word))
                    {
                        // If there is no kanji in the word, only display the kana as the word.
                        <span class="japanese_hiragana">&nbsp;</span>
                        <span class="japanese_fullword">@entry.JapaneseData.First().Reading</span>
                    }
                    else
                    {
                        <span class="japanese_hiragana">@entry.JapaneseData.First().Reading</span>
                        <span class="japanese_fullword">@entry.JapaneseData.First().Word</span>
                    }
                </div>
                <div class="japanese_tags">
                    <span class="jap_tags">(tags)</span>
                </div>
            </div>
            <div class="english_info">
                @foreach (var englishEntry in entry.EnglishData)
                {
                <div class="word_meaning">
                    <span class="meaning_tags">@String.Join(", ", englishEntry.PartsOfSpeech)</span>
                    <span class="meaning_definition">@($"{_localEnglishCount}. ") @String.Join("; ", englishEntry.EnglishDefinitions)</span>
                    <br />
                    <br />
                </div>
                    _localEnglishCount++;
                }
            </div>
            <br />
            <br />
        </div>
        _localEnglishCount = 1;
    }
    <br />
}

@code {
    // Search term from the URL so links to searches can be saved. 
    [Parameter]
    public string SearchTerm { get; set; }

    private List<RetrievedDictionaryModel.Entry> dictionaryEntries;
    private string _searchTerm = string.Empty;
    private string _entryCount = string.Empty;
    private int _localEnglishCount = 1;

    protected override async Task OnInitializedAsync()
    {
        if (!string.IsNullOrEmpty(SearchTerm))
        {
            // If there's a provided URL parameter it intializes searching dictionary with the URL parameter.
            _searchTerm = SearchTerm;
            await SearchDictionaryAsync();
        }
    }

    /// <summary>
    /// Searches the dictionary and updates dictionary entries using the _searchTerm property as the input.
    /// </summary>
    private async Task SearchDictionaryAsync()
    {
        // Retrieves dictionary search results and updates the entryCount to display total amount of results;
        var retrievedEntries = await _dictionarySearchService.SearchDictionaryAsync(_searchTerm);
        _entryCount = retrievedEntries.Count.ToString();

        dictionaryEntries = retrievedEntries;
    }

    // Alternate method so the automatic URL based method doesn't cause an
    // exception when the page is updated using the URL instead of search box.
    private async Task SearchDictionaryManuallyAsync()
    {
        await SearchDictionaryAsync();

        // Changes the URL to reflect search term so it can be saved.
        await ChangePageUrlToSearchTerm();
    }

    // Invokes JS script to change the page URL. It's purely visual and does
    // nothing to back end of the application.
    private async Task ChangePageUrlToSearchTerm()
    {
        var newUrl = $"Search/{_searchTerm}";
        await _jsRunTime.InvokeAsync<string>("ChangeUrl", newUrl);
    }
}
